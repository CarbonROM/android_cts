/**
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#define _GNU_SOURCE
#include <stdlib.h>
#include <dlfcn.h>
#include "common.h"

static void* (*real_memcpy)(void*, const void*, size_t) = NULL;
static void* (*real_memmove)(void*, const void*, size_t) = NULL;
static int s_memory_copy_initialized = 0;

void memory_copy_init(void) {
    real_memcpy = dlsym(RTLD_NEXT, "memcpy");
    if (NULL == real_memcpy) {
        return;
    }
    real_memmove = dlsym(RTLD_NEXT, "memmove");
    if (NULL == real_memmove) {
        return;
    }
    s_memory_copy_initialized = 1;
}

void* memcpy(void* destination, const void* source, size_t num) __overloadable {
    const char *p = source;
    char *q = destination;
    if (s_memory_copy_initialized == 0) {
        memory_copy_init();
    }
    size_t diff = labs(p - q);
    if ((diff > 0) && (diff < num)) {
        exit(EXIT_VULNERABLE);
    }
    return real_memcpy(destination, source, num);
}

void* memmove(void* destination, const void* source, size_t num) __overloadable {
    const char *p = source;
    char *q = destination;
    if (s_memory_copy_initialized == 0) {
        memory_copy_init();
    }
    if ((q < p) || ((size_t) (q - p) >= num)) {
        return real_memcpy(destination, source, num);
    } else {
        return real_memmove(destination, source, num);
    }
}
