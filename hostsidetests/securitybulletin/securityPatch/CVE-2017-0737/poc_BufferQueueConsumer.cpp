/*
 * Copyright 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <inttypes.h>

#define private public

#include <gui/BufferItem.h>
#include <gui/IConsumerListener.h>
#include <gui/IProducerListener.h>
#include "poc_BufferQueueConsumer.h"
#include "poc_BufferQueueCore.h"

#include <binder/IPCThreadState.h>
#include <binder/PermissionCache.h>
#include <private/android_filesystem_config.h>

namespace android {

EvilBufferQueueConsumer::EvilBufferQueueConsumer(
    const sp<BufferQueueCore>& core)
    : mCore(core), mSlots(core->mSlots), mConsumerName() {}

EvilBufferQueueConsumer::~EvilBufferQueueConsumer() {}

status_t EvilBufferQueueConsumer::acquireBuffer(BufferItem* outBuffer,
                                                nsecs_t expectedPresent,
                                                uint64_t maxFrameNumber) {
  {
    outBuffer->mGraphicBuffer = new GraphicBuffer;
    outBuffer->mFence = Fence::NO_FENCE;
    outBuffer->mSlot = 0x666666;
    return NO_ERROR;
  }

  int numDroppedBuffers = 0;
  sp<IProducerListener> listener;
  {
    Mutex::Autolock lock(mCore->mMutex);

    int numAcquiredBuffers = 0;
    for (int s : mCore->mActiveBuffers) {
      if (mSlots[s].mBufferState.isAcquired()) {
        ++numAcquiredBuffers;
      }
    }
    if (numAcquiredBuffers >= mCore->mMaxAcquiredBufferCount + 1) {
      return INVALID_OPERATION;
    }

    bool sharedBufferAvailable =
        mCore->mSharedBufferMode && mCore->mAutoRefresh &&
        mCore->mSharedBufferSlot != BufferQueueCore::INVALID_BUFFER_SLOT;

    if (mCore->mQueue.empty() && !sharedBufferAvailable) {
      return NO_BUFFER_AVAILABLE;
    }

    BufferQueueCore::Fifo::iterator front(mCore->mQueue.begin());

    if (expectedPresent != 0 && !mCore->mQueue.empty()) {
      const int MAX_REASONABLE_NSEC = 1000000000ULL;

      while (mCore->mQueue.size() > 1 && !mCore->mQueue[0].mIsAutoTimestamp) {
        const BufferItem& bufferItem(mCore->mQueue[1]);

        if (maxFrameNumber && bufferItem.mFrameNumber > maxFrameNumber) {
          break;
        }

        nsecs_t desiredPresent = bufferItem.mTimestamp;
        if (desiredPresent < expectedPresent - MAX_REASONABLE_NSEC ||
            desiredPresent > expectedPresent) {
          break;
        }

        if (!front->mIsStale) {
          mSlots[front->mSlot].mBufferState.freeQueued();

          if (!mCore->mSharedBufferMode &&
              mSlots[front->mSlot].mBufferState.isFree()) {
            mSlots[front->mSlot].mBufferState.mShared = false;
          }

          if (!mSlots[front->mSlot].mBufferState.isShared()) {
            mCore->mActiveBuffers.erase(front->mSlot);
            mCore->mFreeBuffers.push_back(front->mSlot);
          }

          listener = mCore->mConnectedProducerListener;
          ++numDroppedBuffers;
        }

        mCore->mQueue.erase(front);
        front = mCore->mQueue.begin();
      }

      nsecs_t desiredPresent = front->mTimestamp;
      bool bufferIsDue = desiredPresent <= expectedPresent ||
                         desiredPresent > expectedPresent + MAX_REASONABLE_NSEC;
      bool consumerIsReady =
          maxFrameNumber > 0 ? front->mFrameNumber <= maxFrameNumber : true;
      if (!bufferIsDue || !consumerIsReady) {
        return PRESENT_LATER;
      }

    }

    int slot = BufferQueueCore::INVALID_BUFFER_SLOT;

    if (sharedBufferAvailable && mCore->mQueue.empty()) {
      mCore->waitWhileAllocatingLocked();

      slot = mCore->mSharedBufferSlot;

      outBuffer->mGraphicBuffer = mSlots[slot].mGraphicBuffer;
      outBuffer->mFence = Fence::NO_FENCE;
      outBuffer->mCrop = mCore->mSharedBufferCache.crop;
      outBuffer->mTransform =
          mCore->mSharedBufferCache.transform &
          ~static_cast<uint32_t>(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);
      outBuffer->mScalingMode = mCore->mSharedBufferCache.scalingMode;
      outBuffer->mDataSpace = mCore->mSharedBufferCache.dataspace;
      outBuffer->mFrameNumber = mCore->mFrameCounter;
      outBuffer->mSlot = slot;
      outBuffer->mAcquireCalled = mSlots[slot].mAcquireCalled;
      outBuffer->mTransformToDisplayInverse =
          (mCore->mSharedBufferCache.transform &
           NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != 0;
      outBuffer->mSurfaceDamage = Region::INVALID_REGION;
      outBuffer->mQueuedBuffer = false;
      outBuffer->mIsStale = false;
      outBuffer->mAutoRefresh = mCore->mSharedBufferMode && mCore->mAutoRefresh;
    } else {
      slot = front->mSlot;
      *outBuffer = *front;
    }


    if (!outBuffer->mIsStale) {
      mSlots[slot].mAcquireCalled = true;
      if (mCore->mQueue.empty()) {
        mSlots[slot].mBufferState.acquireNotInQueue();
      } else {
        mSlots[slot].mBufferState.acquire();
      }
      mSlots[slot].mFence = Fence::NO_FENCE;
    }

    if (outBuffer->mAcquireCalled) {
      outBuffer->mGraphicBuffer = NULL;
    }

    mCore->mQueue.erase(front);

    mCore->mDequeueCondition.broadcast();

    mCore->mOccupancyTracker.registerOccupancyChange(mCore->mQueue.size());

  }

  if (listener != NULL) {
    for (int i = 0; i < numDroppedBuffers; ++i) {
      listener->onBufferReleased();
    }
  }

  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::detachBuffer(int slot) {
  Mutex::Autolock lock(mCore->mMutex);

  if (mCore->mIsAbandoned) {
    return NO_INIT;
  }

  if (mCore->mSharedBufferMode || slot == mCore->mSharedBufferSlot) {
    return BAD_VALUE;
  }

  if (slot < 0 || slot >= BufferQueueDefs::NUM_BUFFER_SLOTS) {
    return BAD_VALUE;
  } else if (!mSlots[slot].mBufferState.isAcquired()) {
    return BAD_VALUE;
  }

  mSlots[slot].mBufferState.detachConsumer();
  mCore->mActiveBuffers.erase(slot);
  mCore->mFreeSlots.insert(slot);
  mCore->clearBufferSlotLocked(slot);
  mCore->mDequeueCondition.broadcast();

  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::attachBuffer(
    int* outSlot, const sp<android::GraphicBuffer>& buffer) {

  if (outSlot == NULL) {
    return BAD_VALUE;
  } else if (buffer == NULL) {
    return BAD_VALUE;
  }

  Mutex::Autolock lock(mCore->mMutex);

  if (mCore->mSharedBufferMode) {
    return BAD_VALUE;
  }

  int numAcquiredBuffers = 0;
  for (int s : mCore->mActiveBuffers) {
    if (mSlots[s].mBufferState.isAcquired()) {
      ++numAcquiredBuffers;
    }
  }

  if (numAcquiredBuffers >= mCore->mMaxAcquiredBufferCount + 1) {
    return INVALID_OPERATION;
  }

  if (buffer->getGenerationNumber() != mCore->mGenerationNumber) {
    return BAD_VALUE;
  }

  int found = BufferQueueCore::INVALID_BUFFER_SLOT;
  if (!mCore->mFreeSlots.empty()) {
    auto slot = mCore->mFreeSlots.begin();
    found = *slot;
    mCore->mFreeSlots.erase(slot);
  } else if (!mCore->mFreeBuffers.empty()) {
    found = mCore->mFreeBuffers.front();
    mCore->mFreeBuffers.remove(found);
  }
  if (found == BufferQueueCore::INVALID_BUFFER_SLOT) {
    return NO_MEMORY;
  }

  mCore->mActiveBuffers.insert(found);
  *outSlot = found;

  mSlots[*outSlot].mGraphicBuffer = buffer;
  mSlots[*outSlot].mBufferState.attachConsumer();
  mSlots[*outSlot].mNeedsReallocation = true;
  mSlots[*outSlot].mFence = Fence::NO_FENCE;
  mSlots[*outSlot].mFrameNumber = 0;

  mSlots[*outSlot].mAcquireCalled = false;

  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::releaseBuffer(int slot, uint64_t frameNumber,
                                                const sp<Fence>& releaseFence,
                                                EGLDisplay eglDisplay,
                                                EGLSyncKHR eglFence) {

  if (slot < 0 || slot >= BufferQueueDefs::NUM_BUFFER_SLOTS ||
      releaseFence == NULL) {
    return BAD_VALUE;
  }

  sp<IProducerListener> listener;
  {
    Mutex::Autolock lock(mCore->mMutex);

    if (frameNumber != mSlots[slot].mFrameNumber &&
        !mSlots[slot].mBufferState.isShared()) {
      return STALE_BUFFER_SLOT;
    }

    if (!mSlots[slot].mBufferState.isAcquired()) {
      return BAD_VALUE;
    }

    mSlots[slot].mEglDisplay = eglDisplay;
    mSlots[slot].mEglFence = eglFence;
    mSlots[slot].mFence = releaseFence;
    mSlots[slot].mBufferState.release();

    if (!mCore->mSharedBufferMode && mSlots[slot].mBufferState.isFree()) {
      mSlots[slot].mBufferState.mShared = false;
    }
    if (!mSlots[slot].mBufferState.isShared()) {
      mCore->mActiveBuffers.erase(slot);
      mCore->mFreeBuffers.push_back(slot);
    }

    listener = mCore->mConnectedProducerListener;

    mCore->mDequeueCondition.broadcast();
  }

  if (listener != NULL) {
    listener->onBufferReleased();
  }

  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::connect(
    const sp<IConsumerListener>& consumerListener, bool controlledByApp) {

  if (consumerListener == NULL) {
    return BAD_VALUE;
  }


  Mutex::Autolock lock(mCore->mMutex);

  if (mCore->mIsAbandoned) {
    return NO_INIT;
  }
  mCore->mConsumerListener = consumerListener;
  mCore->mConsumerControlledByApp = controlledByApp;

  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::disconnect() {

  Mutex::Autolock lock(mCore->mMutex);

  if (mCore->mConsumerListener == NULL) {
    return BAD_VALUE;
  }

  mCore->mIsAbandoned = true;
  mCore->mConsumerListener = NULL;
  mCore->mQueue.clear();
  mCore->freeAllBuffersLocked();
  mCore->mSharedBufferSlot = BufferQueueCore::INVALID_BUFFER_SLOT;
  mCore->mDequeueCondition.broadcast();
  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::getReleasedBuffers(uint64_t* outSlotMask) {

  if (outSlotMask == NULL) {
    return BAD_VALUE;
  }

  Mutex::Autolock lock(mCore->mMutex);

  if (mCore->mIsAbandoned) {
    return NO_INIT;
  }

  uint64_t mask = 0;
  for (int s = 0; s < BufferQueueDefs::NUM_BUFFER_SLOTS; ++s) {
    if (!mSlots[s].mAcquireCalled) {
      mask |= (1ULL << s);
    }
  }

  BufferQueueCore::Fifo::iterator current(mCore->mQueue.begin());
  while (current != mCore->mQueue.end()) {
    if (current->mAcquireCalled) {
      mask &= ~(1ULL << current->mSlot);
    }
    ++current;
  }

  *outSlotMask = mask;
  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::setDefaultBufferSize(uint32_t width,
                                                       uint32_t height) {
  if (width == 0 || height == 0) {
    return BAD_VALUE;
  }


  Mutex::Autolock lock(mCore->mMutex);
  mCore->mDefaultWidth = width;
  mCore->mDefaultHeight = height;
  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::setMaxBufferCount(int bufferCount) {

  if (bufferCount < 1 || bufferCount > BufferQueueDefs::NUM_BUFFER_SLOTS) {
    return BAD_VALUE;
  }

  Mutex::Autolock lock(mCore->mMutex);

  if (mCore->mConnectedApi != BufferQueueCore::NO_CONNECTED_API) {
    return INVALID_OPERATION;
  }

  if (bufferCount < mCore->mMaxAcquiredBufferCount) {
    return BAD_VALUE;
  }

  int delta =
      mCore->getMaxBufferCountLocked(
          mCore->mAsyncMode, mCore->mDequeueBufferCannotBlock, bufferCount) -
      mCore->getMaxBufferCountLocked();
  if (!mCore->adjustAvailableSlotsLocked(delta)) {
    return BAD_VALUE;
  }

  mCore->mMaxBufferCount = bufferCount;
  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::setMaxAcquiredBufferCount(
    int maxAcquiredBuffers) {

  if (maxAcquiredBuffers < 1 ||
      maxAcquiredBuffers > BufferQueueCore::MAX_MAX_ACQUIRED_BUFFERS) {
    return BAD_VALUE;
  }

  sp<IConsumerListener> listener;
  {
    Mutex::Autolock lock(mCore->mMutex);
    mCore->waitWhileAllocatingLocked();

    if (mCore->mIsAbandoned) {
      return NO_INIT;
    }

    if (maxAcquiredBuffers == mCore->mMaxAcquiredBufferCount) {
      return NO_ERROR;
    }

    int acquiredCount = 0;
    for (int slot : mCore->mActiveBuffers) {
      if (mSlots[slot].mBufferState.isAcquired()) {
        acquiredCount++;
      }
    }
    if (acquiredCount > maxAcquiredBuffers) {
      return BAD_VALUE;
    }

    if ((maxAcquiredBuffers + mCore->mMaxDequeuedBufferCount +
         (mCore->mAsyncMode || mCore->mDequeueBufferCannotBlock ? 1 : 0)) >
        mCore->mMaxBufferCount) {
      return BAD_VALUE;
    }

    int delta = maxAcquiredBuffers - mCore->mMaxAcquiredBufferCount;
    if (!mCore->adjustAvailableSlotsLocked(delta)) {
      return BAD_VALUE;
    }

    mCore->mMaxAcquiredBufferCount = maxAcquiredBuffers;
    if (delta < 0) {
      listener = mCore->mConsumerListener;
    }
  }
  if (listener != NULL) {
    listener->onBuffersReleased();
  }

  return NO_ERROR;
}

void EvilBufferQueueConsumer::setConsumerName(const String8& name) {
  Mutex::Autolock lock(mCore->mMutex);
  mCore->mConsumerName = name;
  mConsumerName = name;
}

status_t EvilBufferQueueConsumer::setDefaultBufferFormat(
    PixelFormat defaultFormat) {
  Mutex::Autolock lock(mCore->mMutex);
  mCore->mDefaultBufferFormat = defaultFormat;
  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::setDefaultBufferDataSpace(
    android_dataspace defaultDataSpace) {
  Mutex::Autolock lock(mCore->mMutex);
  mCore->mDefaultBufferDataSpace = defaultDataSpace;
  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::setConsumerUsageBits(uint32_t usage) {
  Mutex::Autolock lock(mCore->mMutex);
  mCore->mConsumerUsageBits = usage;
  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::setTransformHint(uint32_t hint) {
  Mutex::Autolock lock(mCore->mMutex);
  mCore->mTransformHint = hint;
  return NO_ERROR;
}

sp<NativeHandle> EvilBufferQueueConsumer::getSidebandStream() const {
  Mutex::Autolock lock(mCore->mMutex);
  return mCore->mSidebandStream;
}

status_t EvilBufferQueueConsumer::getOccupancyHistory(
    bool forceFlush, std::vector<OccupancyTracker::Segment>* outHistory) {
  Mutex::Autolock lock(mCore->mMutex);
  *outHistory = mCore->mOccupancyTracker.getSegmentHistory(forceFlush);
  return NO_ERROR;
}

status_t EvilBufferQueueConsumer::discardFreeBuffers() {
  Mutex::Autolock lock(mCore->mMutex);
  mCore->discardFreeBuffersLocked();
  return NO_ERROR;
}

void EvilBufferQueueConsumer::dump(String8& result, const char* prefix) const {
  const IPCThreadState* ipc = IPCThreadState::self();
  const pid_t pid = ipc->getCallingPid();
  const uid_t uid = ipc->getCallingUid();
  if ((uid != AID_SHELL) &&
      !PermissionCache::checkPermission(String16("android.permission.DUMP"),
                                        pid, uid)) {
    result.appendFormat(
        "Permission Denial: can't dump BufferQueueConsumer "
        "from pid=%d, uid=%d\n",
        pid, uid);
    android_errorWriteWithInfoLog(0x534e4554, "27046057", uid, NULL, 0);
  } else {
    mCore->dump(result, prefix);
  }
}

}
