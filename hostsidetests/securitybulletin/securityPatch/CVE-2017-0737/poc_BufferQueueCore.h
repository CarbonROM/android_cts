/*
 * Copyright 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef ANDROID_GUI_BUFFERQUEUECORE_H
#define ANDROID_GUI_BUFFERQUEUECORE_H

#include <gui/BufferItem.h>
#include <gui/BufferQueueDefs.h>
#include <gui/BufferSlot.h>
#include "poc_OccupancyTracker.h"

#include <utils/Condition.h>
#include <utils/Mutex.h>
#include <utils/NativeHandle.h>
#include <utils/RefBase.h>
#include <utils/String8.h>
#include <utils/StrongPointer.h>
#include <utils/Trace.h>
#include <utils/Vector.h>

#include <list>
#include <set>

namespace android {

class IConsumerListener;
class IGraphicBufferAlloc;
class IProducerListener;

class BufferQueueCore : public virtual RefBase {

    friend class BufferQueueProducer;
    friend class BufferQueueConsumer;

public:
    enum { INVALID_BUFFER_SLOT = BufferItem::INVALID_BUFFER_SLOT };
    enum { MAX_MAX_ACQUIRED_BUFFERS = BufferQueueDefs::NUM_BUFFER_SLOTS - 2 };

    enum {
        CURRENTLY_CONNECTED_API = -1,

        NO_CONNECTED_API        = 0,
    };

    typedef Vector<BufferItem> Fifo;

    BufferQueueCore(const sp<IGraphicBufferAlloc>& allocator = NULL);
    virtual ~BufferQueueCore();

    // made public for poc
    sp<IConsumerListener> mConsumerListener;

private:
    void dump(String8& result, const char* prefix) const;

    int getMinUndequeuedBufferCountLocked() const;

    int getMinMaxBufferCountLocked() const;

    int getMaxBufferCountLocked() const;

    int getMaxBufferCountLocked(bool asyncMode,
            bool dequeueBufferCannotBlock, int maxBufferCount) const;

    void clearBufferSlotLocked(int slot);

    void freeAllBuffersLocked();

    void discardFreeBuffersLocked();

    bool adjustAvailableSlotsLocked(int delta);

    void waitWhileAllocatingLocked() const;

    sp<IGraphicBufferAlloc> mAllocator;

    mutable Mutex mMutex;

    bool mIsAbandoned;

    bool mConsumerControlledByApp;

    String8 mConsumerName;

    uint32_t mConsumerUsageBits;

    int mConnectedApi;
    pid_t mConnectedPid;

    sp<IProducerListener> mLinkedToDeath;

    sp<IProducerListener> mConnectedProducerListener;

    BufferQueueDefs::SlotsType mSlots;

    Fifo mQueue;

    std::set<int> mFreeSlots;

    std::list<int> mFreeBuffers;

    std::list<int> mUnusedSlots;

    std::set<int> mActiveBuffers;

    mutable Condition mDequeueCondition;

    bool mDequeueBufferCannotBlock;

    PixelFormat mDefaultBufferFormat;

    uint32_t mDefaultWidth;

    uint32_t mDefaultHeight;

    android_dataspace mDefaultBufferDataSpace;

    int mMaxBufferCount;

    int mMaxAcquiredBufferCount;

    int mMaxDequeuedBufferCount;

    bool mBufferHasBeenQueued;

    uint64_t mFrameCounter;

    uint32_t mTransformHint;

    sp<NativeHandle> mSidebandStream;

    bool mIsAllocating;

    mutable Condition mIsAllocatingCondition;

    bool mAllowAllocation;

    uint64_t mBufferAge;

    uint32_t mGenerationNumber;

    bool mAsyncMode;

    bool mSharedBufferMode;

    bool mAutoRefresh;

    int mSharedBufferSlot;

    struct SharedBufferCache {
        SharedBufferCache(Rect _crop, uint32_t _transform, int _scalingMode,
                android_dataspace _dataspace)
        : crop(_crop),
          transform(_transform),
          scalingMode(_scalingMode),
          dataspace(_dataspace) {
        };

        Rect crop;
        uint32_t transform;
        uint32_t scalingMode;
        android_dataspace dataspace;
    } mSharedBufferCache;

    int mLastQueuedSlot;

    OccupancyTracker mOccupancyTracker;

    const uint64_t mUniqueId;

};

}

#endif
