/**
* Copyright(C) 2019 The Android Open Source Project
*
* Licensed under the Apache License, Version 2.0(the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#include <OMX_Component.h>
#include <OMX_Types.h>
#include <binder/IServiceManager.h>
#include <binder/MemoryDealer.h>
#include <binder/Parcel.h>
#include <media/IMediaPlayer.h>
#include <media/IMediaPlayerClient.h>
#include <media/IMediaPlayerService.h>
#include <media/IMediaRecorder.h>
#include <media/IOMX.h>
#include <media/hardware/HardwareAPI.h>
#include <sys/stat.h>
#include <sys/time.h>

using namespace android;
struct DummyOMXObserver : public BnOMXObserver {
public:
  DummyOMXObserver() {}

  virtual void onMessages(const std::list<omx_message> &messages __unused) {}

protected:
  virtual ~DummyOMXObserver() {}
};

typedef struct OMX_VENDOR_EXTRADATATYPE {
  OMX_U32 nPortIndex;
  OMX_U32 nDataSize; // Size of the supporting data to follow
  OMX_U8 *pData;     // Supporting data hint
} OMX_VENDOR_EXTRADATATYPE;

bool fuzzIOMXComponentSetConfig() {
  sp<IServiceManager> sm = defaultServiceManager();

  sp<IBinder> binder = sm->getService(String16("media.player"));
  sp<IMediaPlayerService> mediaPlayerService =
      interface_cast<IMediaPlayerService>(binder);

  if (mediaPlayerService == NULL) {
    ALOGI("mediaPlayerService == NULL");
    return false;
  }

  sp<IOMX> service = mediaPlayerService->getOMX();
  if (service == NULL) {
    ALOGI("service == NULL");
    return false;
  }
  BpInterface<IOMX> *bp = static_cast<BpInterface<IOMX> *>(service.get());

  int node = 0;
  Parcel data, reply;
  // get node id
  ALOGI("ALLOCATE_NODE: 4");
  data.writeInterfaceToken(bp->getInterfaceDescriptor());

  data.writeCString("OMX.qcom.video.decoder.avc");

  sp<DummyOMXObserver> observer = new DummyOMXObserver();
  data.writeStrongBinder(IInterface::asBinder(observer));

  // 4: ALLOCATE_NODE
  IInterface::asBinder(bp)->transact(4 /*ALLOCATE_NODE*/, data, &reply);
  int error = reply.readInt32();
  node = reply.readInt32();
  ALOGI("error: %d, node: %d", error, node);

  data.freeData();
  reply.freeData();

  // set config
  ALOGI("SET_CONFIG: 10");

  data.writeInterfaceToken(bp->getInterfaceDescriptor());

  data.writeInt32(node);       // node
  data.writeInt32(0xFF000003); // OMX_IndexVendorVideoExtraData

  int paramsSize = sizeof(OMX_VENDOR_EXTRADATATYPE);
  OMX_VENDOR_EXTRADATATYPE *params =
      (OMX_VENDOR_EXTRADATATYPE *)malloc(paramsSize);
  if (params == NULL) {
    ALOGE("memory allocation failed");
    return false;
  }

  params->nDataSize = 5;
  params->pData = (OMX_U8 *)(0);
  data.writeInt64(paramsSize);
  data.write(params, paramsSize);

  IInterface::asBinder(bp)->transact(10 /*SET_CONFIG*/, data, &reply);

  error = reply.readInt32();
  ALOGI("error: %d", error);
  free(params);
  return true;
}
int main() {
   return (int)(!fuzzIOMXComponentSetConfig());
}
